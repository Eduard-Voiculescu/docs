---
title: GraphQL API
---

Tato příručka vysvětluje GraphQL Query API, které se používá pro protokol Graf.

## Dotazy

Ve schématu podgrafu definujete typy nazvané `Entity`. Pro každý typ `Entity` bude na nejvyšší úrovni typu `Query` vygenerováno pole `entity` a `entity`. Všimněte si, že `dotaz` nemusí být při použití Grafu zahrnut na vrcholu `graphql` dotazu.

### Příklady

Dotaz na jednu entitu `Token` definovanou ve vašem schématu:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **Poznámka:** Při dotazování na jednu entitu je pole `id` povinné a musí to být řetězec.

Dotaz na všechny entity `Token`:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Třídění

Při dotazování na kolekci lze parametr `orderBy` použít k seřazení podle určitého atributu. Kromě toho lze pomocí parametru `orderDirection` určit směr řazení, `asc` pro vzestupné nebo `desc` pro sestupné.

#### Příklad

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### Příklad vnořeného třídění entit

Od verze Uzel grafu [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) lze entity třídit na základě vnořených entit.

V následujícím příkladu seřadíme tokeny podle jména jejich vlastníka:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> V současné době můžete řadit podle jednoúrovňových typů `String` nebo `ID` v polích `@entity` a `@derivedFrom`. Bohužel [třídění podle rozhraní na jednoúrovňových hlubokých entitách](https://github.com/graphprotocol/graph-node/pull/4058), třídění podle polí, která jsou poli, a vnořených entit zatím není podporováno.

### Stránkování

Při dotazování na kolekci lze parametr `První` použít pro stránkování od začátku kolekce. Stojí za zmínku, že výchozí řazení je podle ID ve vzestupném alfanumerickém pořadí, nikoli podle času vytvoření.

Dále lze parametr `skip` použít k přeskočení entit a stránkování, např. `first:100` zobrazí prvních 100 entit a `first:100, skip:100` zobrazí dalších 100 entit.

Dotazy by se měly vyvarovat používání velmi velkých hodnot `přeskočit`, protože mají obecně nízkou výkonnost. Pro získání velkého počtu položek je mnohem lepší procházet entity na základě atributu, jak je uvedeno v posledním příkladu.

#### Příklad s použitím `first`

Dotaz na prvních 10 tokenů:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

Pro dotazování na skupiny entit uprostřed kolekce lze použít parametr `skip` ve spojení s parametrem `first` pro vynechání určitého počtu entit počínaje začátkem kolekce.

#### Příklad s použitím `first` a `skip`

Dotaz na 10 entit `Token`, posunutých o 10 míst od začátku kolekce:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Příklad s použitím `first` a `id_ge`

Pokud klient potřebuje získat velký počet entit, je mnohem výkonnější založit dotazy na atributu a filtrovat podle něj. Klient by například pomocí tohoto dotazu získal velký počet tokenů:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

Poprvé by odeslal dotaz s `lastID = ""` a při dalších požadavcích by nastavil `lastID` na atribut `id` poslední entity v předchozím požadavku. Tento přístup bude fungovat podstatně lépe než použití rostoucích hodnot `skip`.

### Filtrování

Pomocí parametru `where` můžete v dotazech filtrovat různé vlastnosti. V rámci parametru `kde` můžete filtrovat podle více hodnot.

#### Příklad s použitím `where`

Výzvy k dotazu s výsledkem `neúspěšný`:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Pro porovnání hodnot můžete použít přípony jako `_gt`, `_lte`:

#### Příklad filtrování rozsahu

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Příklad pro filtrování bloků

Entity můžete filtrovat také pomocí `_change_block(number_gte: Int)` - filtruje entity, které byly aktualizovány v zadaném bloku nebo po něm.

To může být užitečné, pokud chcete načíst pouze entity, které se změnily například od posledního dotazování. Nebo může být užitečná pro zkoumání nebo ladění změn entit v podgrafu (v kombinaci s blokovým filtrem můžete izolovat pouze entity, které se změnily v určitém bloku).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### Příklad vnořeného filtrování entit

Filtrování na základě vnořených entit je možné v polích s příponou `_`.

To může být užitečné, pokud chcete načíst pouze entity, jejichž entity podřízené úrovně splňují zadané podmínky.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Logické operátory

Od verze Uzel grafu [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) můžete seskupit více parametrů v jednom argumentu `where` pomocí operátorů `and` nebo `or` a filtrovat výsledky na základě více kritérií.

##### Operátor `AND`

V následujícím příkladu filtrujeme výzvy s `outcome` `succeeded` a `number` větším nebo rovným `100`.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Syntaktický cukr:** Výše uvedený dotaz můžete zjednodušit odstraněním operátoru `a` předáním podvýrazu odděleného čárkami.
> 
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### Operátor `OR`

V následujícím příkladu filtrujeme výzvy s `outcome` `succeeded` nebo `number` větším nebo rovným `100`.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Poznámka**: Při sestavování dotazů je důležité zvážit dopad použití operátoru `nebo` na výkon. Operátor `nebo` sice může být užitečným nástrojem pro rozšíření výsledků vyhledávání, ale může s sebou nést i značné náklady. Jedním z hlavních problémů operátoru `nebo` je, že může způsobit zpomalení dotazů. Je to proto, že `nebo` vyžaduje, aby databáze prohledala více indexů, což může být časově náročný proces. Abyste se těmto problémům vyhnuli, doporučujeme vývojářům používat operátory and místo or, kdykoli je to možné. To umožňuje přesnější filtrování a může vést k rychlejším a přesnějším dotazům.

#### Všechny filtry

Úplný seznam přípon parametrů:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Upozorňujeme, že některé přípony jsou podporovány pouze pro určité typy. Například `Boolean` podporuje pouze `_not`, `_in` a `_not_in`, ale `_` je k dispozici pouze pro typy objektů a rozhraní.

Kromě toho jsou jako součást argumentu `where` k dispozici následující globální filtry:

```gr
_change_block(number_gte: Int)
```

### Dotazy na cestování čase

Můžete se dotazovat na stav entit nejen pro nejnovější blok, což je výchozí nastavení, ale také pro libovolný blok v minulosti. Blok, u kterého má dotaz proběhnout, lze zadat buď číslem bloku, nebo jeho blokovým hashem, a to tak, že do polí toplevel dotazů zahrnete argument `blok`.

Výsledek takového dotazu se v průběhu času nemění, tj. dotaz na určitý minulý blok vrátí stejný výsledek bez ohledu na to, kdy je proveden, s výjimkou toho, že pokud se dotazujete na blok velmi blízko hlavy řetězce, výsledek se může změnit, pokud se ukáže, že tento blok není v hlavním řetězci a řetězec se reorganizuje. Jakmile lze blok považovat za konečný, výsledek dotazu se nezmění.

Všimněte si, že současná implementace stále podléhá určitým omezením, která by mohla tyto záruky porušit. Implementace nemůže vždy zjistit, že daný blokový hash vůbec není v hlavním řetězci, nebo že výsledek dotazu podle blokového hashe na blok, který ještě nelze považovat za finální, může být ovlivněn reorganizací bloku probíhající současně s dotazem. Neovlivňují výsledky dotazů podle blokové hash, pokud je blok finální a je známo, že je v hlavním řetězci. [Toto Problém ](https://github.com/graphprotocol/graph-node/issues/1405) podrobně vysvětluje, jaká jsou tato omezení.

#### Příklad

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Tento dotaz vrátí entity `Challenge` a k nim přiřazené entity `Application` tak, jak existovaly bezprostředně po zpracování bloku číslo 8,000,000.

#### Příklad

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Tento dotaz vrátí entity `Challenge` a s nimi spojené entity `Application` tak, jak existovaly bezprostředně po zpracování bloku s daným hashem.

### Fulltextové Vyhledávání dotazy

Pole pro fulltextové vyhledávání poskytují expresivní rozhraní API pro textové vyhledávání, které lze přidat do schématu podgrafů a přizpůsobit je. Viz [Definice polí pro fulltextové vyhledávání](/developing/creating-a-subgraph#defining-fulltext-search-fields) pro přidání fulltextového vyhledávání do podgrafu.

Fulltextové vyhledávací dotazy mají jedno povinné pole `text` pro zadání hledaných výrazů. V tomto vyhledávacím poli `text` je k dispozici několik speciálních fulltextových operátorů.

Operátory fulltextového vyhledávání:

| Symbol      | Operátor    | Popis                                                                                                                                |
| ----------- | ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `&`     | `a`         | Pro kombinaci více vyhledávacích výrazů do filtru pro entity, které obsahují všechny zadané výrazy                                   |
| &#x7c;      | `Or`        | Queries with multiple search terms separated by the or operator will return all entities with a match from any of the provided terms |
| `<->` | `Follow by` | Specify the distance between two words.                                                                                              |
| `:*`        | `Prefix`    | Use the prefix search term to find words whose prefix match (2 characters required.)                                                 |

#### Příklady

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Validation

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## Schema

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### Entities

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.

### Subgraph Metadata

All subgraphs have an auto-generated `_Meta_` object, which provides access to subgraph metadata. This can be queried as follows:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

Pokud je uveden blok, metadata se vztahují k tomuto bloku, pokud ne, použije se poslední indexovaný blok. Pokud je blok uveden, musí se nacházet za počátečním blokem podgrafu a musí být menší nebo roven poslednímu Indevovaný bloku.

` deployment` je jedinečné ID, které odpovídá IPFS CID souboru `subgraph.yaml`.

`block` poskytuje informace o posledním bloku (s přihlédnutím k případným omezením bloku předaným do `_meta`):

- hash: hash bloku
- číslo: číslo bloku
- timestamp: časové razítko bloku, pokud je k dispozici (v současné době je k dispozici pouze pro podgrafy indexující sítě EVM)

`hasIndexingErrors` je boolean určující, zda se v podgrafu vyskytly chyby indexování v některém z minulých bloků
